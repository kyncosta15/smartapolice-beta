import { useState } from 'react';
import { supabase } from '@/integrations/supabase/client';

export interface PDFDashboardData {
  // M√©tricas gerais
  totalPolicies: number;
  activePolicies: number;
  expiredPolicies: number;
  expiringNext30Days: number;
  totalMonthlyCost: number;
  totalInsuredValue: number;
  
  // Distribui√ß√µes
  insurerDistribution: Array<{ name: string; value: number; percentage: number; count: number }>;
  typeDistribution: Array<{ name: string; value: number; count: number }>;
  
  // Ap√≥lices recentes (√∫ltimos 30 dias)
  recentPolicies: Array<{
    id: string;
    numero_apolice: string;
    segurado: string;
    seguradora: string;
    valor_mensal: number;
    status: string;
    created_at: string;
  }>;
  
  // Metadados
  generatedAt: Date;
  generatedBy: {
    name: string;
    email: string;
    company?: string;
  };
  
  // Indicadores complementares
  personTypeDistribution: {
    pessoaFisica: number;
    pessoaJuridica: number;
  };
  
  monthlyEvolution: Array<{ month: string; cost: number }>;
}

export function usePDFDashboardData() {
  const [isLoading, setIsLoading] = useState(false);

  const fetchDashboardData = async (): Promise<PDFDashboardData | null> => {
    // Get current user directly from Supabase auth
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      console.error('Usu√°rio n√£o autenticado');
      return null;
    }

    setIsLoading(true);
    
    try {
      console.log('üîç Buscando dados do dashboard para PDF...');
      
      // Buscar todas as ap√≥lices do usu√°rio
      const { data: policies, error } = await supabase
        .from('policies')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Erro ao buscar ap√≥lices:', error);
        return null;
      }

      // Get user data for "generated by" info
      const { data: userData } = await supabase
        .from('users')
        .select('name, company')
        .eq('id', user.id)
        .maybeSingle();

      const generatedBy = {
        name: userData?.name || user.email?.split('@')[0] || 'Usu√°rio',
        email: user.email || '',
        company: userData?.company
      };

      // Calcular m√©tricas
      const totalPolicies = policies?.length || 0;
      const now = new Date();
      const thirtyDaysFromNow = new Date();
      thirtyDaysFromNow.setDate(now.getDate() + 30);

      // Pol√≠ticas ativas vs vencidas vs vencendo
      let activePolicies = 0;
      let expiredPolicies = 0;
      let expiringNext30Days = 0;

      policies?.forEach(policy => {
        if (policy.fim_vigencia) {
          const endDate = new Date(policy.fim_vigencia);
          if (endDate < now) {
            expiredPolicies++;
          } else if (endDate <= thirtyDaysFromNow) {
            expiringNext30Days++;
          } else {
            activePolicies++;
          }
        } else {
          activePolicies++; // Assumir ativa se n√£o tem data de fim
        }
      });

      // Calcular custos
      const totalMonthlyCost = policies?.reduce((sum, p) => 
        sum + (p.custo_mensal || p.valor_mensal_num || 0), 0) || 0;
      
      const totalInsuredValue = policies?.reduce((sum, p) => 
        sum + (p.valor_premio || p.valor_parcela || 0), 0) || 0;

      // Distribui√ß√£o por seguradora
      const insurerCounts = new Map<string, { value: number; count: number }>();
      policies?.forEach(policy => {
        const insurer = policy.seguradora || policy.seguradora_empresa || 'N√£o informado';
        const cost = policy.custo_mensal || policy.valor_mensal_num || 0;
        
        if (insurerCounts.has(insurer)) {
          const current = insurerCounts.get(insurer)!;
          insurerCounts.set(insurer, {
            value: current.value + cost,
            count: current.count + 1
          });
        } else {
          insurerCounts.set(insurer, { value: cost, count: 1 });
        }
      });

      const insurerDistribution = Array.from(insurerCounts.entries()).map(([name, data]) => ({
        name,
        value: data.value,
        count: data.count,
        percentage: totalMonthlyCost > 0 ? Math.round((data.value / totalMonthlyCost) * 100) : 0
      }));

      // Distribui√ß√£o por tipo
      const typeCounts = new Map<string, { value: number; count: number }>();
      policies?.forEach(policy => {
        const type = policy.tipo_seguro || policy.tipo_categoria || 'Outros';
        const cost = policy.custo_mensal || policy.valor_mensal_num || 0;
        
        if (typeCounts.has(type)) {
          const current = typeCounts.get(type)!;
          typeCounts.set(type, {
            value: current.value + cost,
            count: current.count + 1
          });
        } else {
          typeCounts.set(type, { value: cost, count: 1 });
        }
      });

      const typeDistribution = Array.from(typeCounts.entries()).map(([name, data]) => ({
        name,
        value: data.value,
        count: data.count
      }));

      // Ap√≥lices recentes (√∫ltimos 30 dias)
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(now.getDate() - 30);

      const recentPolicies = policies
        ?.filter(policy => new Date(policy.created_at) >= thirtyDaysAgo)
        .slice(0, 10)
        .map(policy => ({
          id: policy.id,
          numero_apolice: policy.numero_apolice || 'N/A',
          segurado: policy.segurado || 'N√£o informado',
          seguradora: policy.seguradora || policy.seguradora_empresa || 'N√£o informado',
          valor_mensal: policy.custo_mensal || policy.valor_mensal_num || 0,
          status: policy.status || 'Ativo',
          created_at: policy.created_at
        })) || [];

      // Distribui√ß√£o pessoa f√≠sica/jur√≠dica
      let pessoaFisica = 0;
      let pessoaJuridica = 0;

      policies?.forEach(policy => {
        const docType = policy.documento_tipo?.toString().toUpperCase();
        if (docType === 'CPF') {
          pessoaFisica++;
        } else if (docType === 'CNPJ') {
          pessoaJuridica++;
        }
      });

      // Evolu√ß√£o mensal (proje√ß√£o 12 meses)
      const monthlyEvolution = [];
      for (let i = 0; i < 12; i++) {
        const date = new Date(now.getFullYear(), now.getMonth() + i, 1);
        const monthKey = date.toLocaleDateString('pt-BR', { 
          month: 'short', 
          year: 'numeric' 
        });
        monthlyEvolution.push({
          month: monthKey,
          cost: totalMonthlyCost // Proje√ß√£o simples, pode ser refinada
        });
      }

      const dashboardData: PDFDashboardData = {
        totalPolicies,
        activePolicies,
        expiredPolicies,
        expiringNext30Days,
        totalMonthlyCost,
        totalInsuredValue,
        insurerDistribution,
        typeDistribution,
        recentPolicies,
        personTypeDistribution: {
          pessoaFisica,
          pessoaJuridica
        },
        monthlyEvolution,
        generatedAt: new Date(),
        generatedBy
      };

      console.log('‚úÖ Dados do dashboard compilados:', dashboardData);
      return dashboardData;

    } catch (error) {
      console.error('Erro ao buscar dados do dashboard:', error);
      return null;
    } finally {
      setIsLoading(false);
    }
  };

  return {
    fetchDashboardData,
    isLoading
  };
}